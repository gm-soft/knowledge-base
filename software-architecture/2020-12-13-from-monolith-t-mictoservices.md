# От микросервисного монолита к оркестратору

Источник: [Блог Александра Бындю](https://blog.byndyu.ru/2020/04/blog-post_14.html)

---

Когда компании решают разделить монолит на микросервисы, в большинстве случаев они последовательно проходят четыре этапа: монолит, микросервисный монолит, микросервисы, оркестратор бизнес-сервисов.

![](/software-architecture/2020-12-13-from-monolith-to-microservices/1.png)

Если вы определите, на каком из этапов находитесь сейчас, это поможет вам понять плюсы и минусы текущего этапа, оценить стоит ли идти на следующий этап и, если стоит, увидеть шаги необходимые для перехода. В каждом разделе вы найдете ссылки для более глубокого погружения в нюансы конкретного перехода.

## Этап №1. Монолит

### 1.1 Характеристики

Обычно монолитную архитектуру можно описать так:

- Единая точка разработки и деплоя
- Единая база данных
- Единый цикл релиза для всех изменений
- В одной системе реализовано несколько бизнес-задач

![](/software-architecture/2020-12-13-from-monolith-to-microservices/2.png)

Погружение в контекст:
- [Pattern: Monolithic Architecture](https://microservices.io/patterns/monolithic.html)
- [Бизнес-гибкость через микросервисную архитектуру](https://blog.byndyu.ru/2020/01/blog-post_21.html)
- [Don’t start with a monolith](https://martinfowler.com/articles/dont-start-monolith.html)

### 1.2 Проблемы

- Система единая, при этом решает много разных бизнес-задач. Разные бизнес-задачи развивают разные подразделения компании и двигаются с разной скоростью. Отсюда возникает проблема с взаимозависимыми релизами разных подразделений, когда все ждут самого медленного.
- Сложно масштабировать бизнес-приложения, которые объединяет монолит. Это приводит к тому, что не учитываются особенности каждого приложения, и масштабирование делается неэффективно.
- При выборе технологического стека для новой бизнес-задачи приходится подстраиваться под среду разработки монолита, хотя этот выбор не всегда является наилучшим.
- Система уходит в релиз целиком, поэтому должна быть протестирована целиком. Это приводит к сложному регрессионному тестированию, затягиванию процесса тестирования и репотинга багов всем поставщикам изменений, замедлению скорости релизов, и, соответственно, увеличению времени time-to-market.
- Последнее ведет к тому, что бизнесу тяжело быстро собрать обратную связь от рынка.

### 1.3 Как перейти на следующий этап

В основе процесса выделения микросервисов лежит вынесение бизнес-задач из монолита в отдельные сервисы. При этом нужно руководствоваться [принципом единственности ответственности](https://blog.byndyu.ru/2009/10/blog-post.html), который перефразируется так: у микросервиса должна быть только одна причина для изменения. Этой причиной является изменение бизнес-логики той единственной задачи, за которую он отвечает.

В дополнение к SRP есть подход от любителей Domain-Driven Design: микросервис ограничивается одним или несколькими [Bounded Context](https://medium.com/design-and-tech-co/implementing-domain-driven-design-for-microservice-architecture-26eb0333d72e). Постепенно у вас образуется набор из микросервисов, где каждый отвечает лишь за свою бизнес-задачу:

![](/software-architecture/2020-12-13-from-monolith-to-microservices/3.png)

Погружение в контекст:
- [Переход от монолитной архитектуры к распределенной](https://blog.byndyu.ru/2014/05/blog-post.html)
- [How to break a Monolith into Microservices](https://martinfowler.com/articles/break-monolith-into-microservices.html)
- [Command and Query Responsibility Segregation (CQRS) на практике](https://blog.byndyu.ru/2014/07/command-and-query-responsibility.html)
- [Работа с унаследованным кодом: Риски, анализ проекта и стратегии работы](https://blog.byndyu.ru/2014/01/blog-post_8.html)
- [StranglerFigApplication](https://martinfowler.com/bliki/StranglerFigApplication.html)

При создании микросервисной архитектуры полезно периодически проверять себя по чеклисту [The Microservice Architecture Assessment](https://microservices.io/platform/microservice-architecture-assessment.html), чтобы не упустить какую-то важную деталь.

## Этап №2. Микросервисный монолит

### 2.1 Характеристики

Все части монолита стали независимыми микросервисами и эти микросервисы должны общаться между собой. Если раньше, находясь внутри одного процесса, сервисы вызывали методы друг друга напрямую, то теперь нужно интегироваться. Из [четырех способов интеграции](https://blog.byndyu.ru/2013/10/integration-patterns.html) в микросервисной архитектуре обычно не используют обмен файлами и стараются не использовать [shared database](https://microservices.io/patterns/data/shared-database.html), зато активно работают с RPC и очередью сообщений.

Получается, что все части монолита распались на микросервисы, а их обратно соединили паутиной синхронных и асинхронных интеграций:

![](/software-architecture/2020-12-13-from-monolith-to-microservices/4.png)

По факту, получился тот же монолит, но с большим количеством новых проблем.

### 2.2 Проблемы

- Прямые связи между микросервисами усложняют анализ проблем. Например, запрос может пройти через 5 микросервисов, прежде, чем вернуться с ответом. Что если на третьем микросервисе запрос завис? Что если там была ошибка? Что если на втором шаге должно было создаться сообщение в очередь, но оно не появилось? Возникает сложность с разбором проблем.
- Предыдущий пункт усложняется, если у микросервиса много экземпляров. Тогда возникает ситуация, что запрос пришел на экземпляр, который завис.
- Архитектуру сложно понять и, чем больше сервисов вы добавляете, тем запутанней всё становится. В целом, добавление новых сервисов нелинейно повышает сложность архитектуры.
- Неизвестно, кто потребители вашего API, что добавляет сложности в проектировании API и его изменении.

Если на пути рефакторинга монолита вы остановитесь на этом этапе, то, вполне резонно, сделаете вывод, что с монолитом было лучше и дешевле.

### 2.3 Как перейти на следующий этап

Основные идеи: локализовать точки интеграции и контролировать все потоки данных. Чтобы этого добиться, надо использовать:

- API Gateway для локализации синхронных взаимодействий и монниторинг/логирование трафика между микросервисами. В идеале, надо иметь визуализацию трассировки любого запроса.
- Service Discovery для отслеживания работоспособности экземпляров микросервиса и перенаправление трафика на "живые" экземпляры.
- Запретить прямые вызовы между микросервисами.

Чтобы избежать типовых проблем и упростить разработку, рекомендую взять на вооружение подходы по повышению отказоустойчивости:

- [Circuit Breaker](https://martinfowler.com/bliki/CircuitBreaker.html)
- [Tolerant Reader](https://martinfowler.com/bliki/TolerantReader.html)
- [Embracing Failure](https://www.susanjfowler.com/blog/2016/8/24/embracing-failure)
- [The Timeout AntiPattern](https://www.oreilly.com/content/microservices-antipatterns-and-pitfalls/#the_timeout_antipattern)
- [Graceful Degradation](https://medium.com/@felipedutratine/microservices-should-be-design-for-failure-b58bccdce0b6)
- [Use versioning only as a last resort](https://martinfowler.com/articles/enterpriseREST.html#versioning)

## Этап №3. Микросервисы

### 3.1 Характеристики

Микросервисы ничего не знают о существовании друг друга: работают со своей базой данных, API и сообщениями в очереди. Каждый микросервис решает только одну бизнес-задачу и старается делать это максимально эффективно, за счет выбора технологий, стратегии масштабирования.

Становится заметна главная черта хорошей архитектуры: сложность системы растет линейно с увеличением количества микросервисов.

![](/software-architecture/2020-12-13-from-monolith-to-microservices/5.png)

Погружение в контекст:

- [Pattern: Microservice Architecture](https://microservices.io/patterns/microservices.html)
- [Microsoft Dev School — Микросервисы, чистый PaaS и конкурс мисс Россия](https://blog.byndyu.ru/2017/07/microsoft-dev-school-paas.html)
- [Microservices, a definition of this new architectural term](https://martinfowler.com/articles/microservices.html)

### 3.2 Проблемы

На этом этапе сложные технические задачи решены, поэтому начинаются проблемы на уровне бизнес-задач:

- реди сотен микросервисов и разных API бизнес не может понять, какие инструменты есть у него в руках. Пазл складывается в стройные картинки только у энтерпрайз архитекторов, а их, как известно, очень мало на Земле.
- Бизнес хочет увидеть лес за деревьями, чтобы понимать, какие есть детали и как из них можно собирать новые продукты, не прибегая к разработке.
- Сборку новых продуктов из существующих кубиков, хочется совместить с продуктовой разработкой, чтобы Владелец продукта сам ориентировался, какие ему доступны ресурсы.

### 3.3 Как перейти на следующий этап

Многие компании не идут дальше, потому что на текущем этапе бизнес-задачи могут решаться уже достаточно быстро и эффективно. Тем, кто решают двигаться дальше:

- Изучите концепцию [Citizen Integrator](https://www.gartner.com/en/documents/3725217/citizen-integrators-bring-application-and-data-integrati). Для наглядного примера заведите себе пару процессов в [Zapier](https://zapier.com/home).
- Опишите микросервисы в виде блоков, решающих бизнес-задачу, и сделайте из них конструктор. Это можно сделать: 1) на готовых инструментах, 2) обернуть BPM-движки типа Camunda, 3) написать всё самим с нуля как, например, [сделали в Леруа Мерлен](https://lm-tech.ru/platformeco/). Все три подхода жизнеспособны. Выбор подхода зависит от стратегии вашей компании и наличии у вас ИТ-архитекторов и хороших программистов.

![](/software-architecture/2020-12-13-from-monolith-to-microservices/6.png)

![](/software-architecture/2020-12-13-from-monolith-to-microservices/7.png)

Погружение в контекст:

- [The Microservices Workflow Automation Cheat Sheet](https://blog.bernd-ruecker.com/the-microservice-workflow-automation-cheat-sheet-fc0a80dc25aa)
- [Clouds, iPaaS, Citizen Integrator and Why India’s Outsourcing Is Losing Money](https://blog.byndyusoft.com/clouds-ipaas-citizen-integrator-and-why-indias-outsourcing-is-loosing-money-924eeafb1b97)

## Этап №4. Оркестратор бизнес-сервисов

### 4.1 Характеристики

Оркестратор бизнес-сервисов обычно является визуальной платформой, где соединяются сервисы, выставляются триггеры и условия ветвления, контролируются все потоки данных: реализована трассировка запросов, логирование событий, автомасштабирование по условиям. Сам оркестратор ничего не знает о специфике бизнес-процессов, которые на нем крутятся.

На этом этапе можете решить задачу создания продукта в визуальном редакторе. Если нужных "квадратиков" не хватает, то программисты создают микросервис, учитывая правила описания сервиса для оркестратора, публикуют API и "кубик" появляется в визуальном редакторе, готовый соединяться с другими участниками бизнес-задачи.

![](/software-architecture/2020-12-13-from-monolith-to-microservices/8.png)

### 4.2 Проблемы

Создание, внедрение и развитие оркестратора бизнес-процессов является дорогим удовольствием. Если ослабить архитектурный контроль, оркестратор может превратиться в узкое место систем, созданных на нем. Чем больше систем создается на оркестраторе, тем больше бизнес зависит от этого решения. В целом, это начинает напоминать проблемы монолита.

### 4.3 Как перейти на следующий этап

На данный момент я не вижу сформировавшегося пятого этапа. Если вы видели жизнь после оркестратора бизнес-сервисов, буду рад увидеть описание вашего опыта в комментариях.

## Заключение

Эти четыре этапа показывают, как мне кажется, естественный ход вещей:

- Вначале приложение небольшое и решает одну бизнес-задачу. Со временем в него добавляют много всего и оно превращается в неповоротливый монолит.
- При первой попытке разделить монолит многие команды не готовы к возрастающей сложности. Монолит делится на много микросервисов, но из-за большого количество взаимосвязей получается тот же монолит, только с новыми проблемами: простейшие задачи типа трейсинга запроса или мониторинга инфраструктуры становятся вызовом для команды разработки.
- Когда сложности решаются, получается стройная и масштабируемая архитектура. Добавление новых микросервисов линейно повышает сложность.
- На последнем этапе приходит бизнес и резонно говорит, что раз есть готовые решения бизнес-задач, то давайте делать новые продукты без разработки. Будем соединять готовые независимые блоки в новые бизнес-процессы через оркестратор.
